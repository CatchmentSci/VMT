function [log_text] = VMT_SaveExcelOutput(excel_path,excel_file,outputType,dataFiles,V,A,z,Map,wse,PVdata)

% Check for existing file
[excel_file,excel_path] = uiputfile('*.xlsx','Save *.xlsx file',...
    fullfile(excel_path,excel_file));

if ischar(excel_path) % The user did not hit "Cancel"
    outfile = fullfile(excel_path,excel_file);
    %log_text = vertcat(log_text,{outfile});
    
    % Delete the old file if it exists
    if exist(outfile, 'file') == 2
        log_text = {'Warning: The file';...
            ['   ' outfile];...
            'already exists. Overwriting file...'};
        delete(outfile)
    end
end

switch outputType
    case 'Multiple'
        %% Multiple MAT Files Loaded
       log_text = vertcat(log_text,{'Writing data to Excel file...';...
        'Multiple transected loaded. Will export Planview Data Only!'});
        % Save MCS Summary to an Excel File
        hwait = waitbar(0,'Exporting Excel File...');
        xlswrite(outfile,{'Path:'}, 'VMTSummary','H3');
        xlswrite(outfile,{'Files:'},'VMTSummary','H4');
        if isempty(guiparams.data_files{1}) || ~isempty(guiparams.mat_file{1}) % Loaded MAT file
            xlswrite(outfile,{guiparams.mat_path},'VMTSummary','I3');
            sout = guiparams.mat_file';
        end
        xlswrite(outfile,sout,'VMTSummary','I4');
        sout = {...
            'VMT: SUMMARY OF MEAN CROSS SECTION' '' '' '' '' '';...
            'VMT ' guiparams.vmt_version{1} guiparams.vmt_version{2} '' '' '';...
            'Date Processed: ' datestr(now) '' '' '' '';...
            '' '' '' '' '' '';...
            'MEAN CROSS SECTION (MCS) PROPERTIES' '' '' '' '' '';...
            'Horz. Grid Node Spacing (m):' '' '' '' '' guiparams.horizontal_grid_node_spacing;...
            'Vert. Grid Node Spacing (m):' '' '' '' '' guiparams.vertical_grid_node_spacing;...
            '' '' '' '' '' '';...
            'SMOOTHED DATA PROPERTIES' '' '' '' '' '';...
            'Smoothed Planview:' '' '' '' '' '';...
            'Vector Spacing, in ground distance (m)' '' '' '' ''  num2str(guiparams.vector_spacing_plan_view*guiparams.horizontal_grid_node_spacing);...
            'Vector Smoothing, in ground distance (m)' '' '' '' '' num2str(2*guiparams.smoothing_window_size*guiparams.horizontal_grid_node_spacing);...
            '' '' '' '' '' '';...
            'DATA STRUCTURE' '' '' '' '' '';...
            '' '1. These data are the computed output from The Velocity Mapping Toolbox (VMT).' '' '' '' '';...
            '' '2. VMT maps the loaded ADCP data to a mean cross-section (MCS), typically a line of best fit to the ADCP positions.' '' '' '' '';...
            '' '3. The ADCP data are then interpolated to a user specified grid (see Cells F6:F7).' '' '' '' '';...
            '' '4. VMT then averages the mapped and interpolated data to the MCS grid.' '' '' '' '';...
            '' '5. For more information, see the VMT homepage: ' '' '' '' '';...
            '' '=HYPERLINK("http://hydroacoustics.usgs.gov/movingboat/VMT/VMT.shtml")' '' '' '' '';...
            'Planview:' '' '' '' '' '';...
            '' '1. Units are indicated in the column titles.' '' '' '' '';...
            '' '2. Values are for layer-avg quanties. Thus "dpthrng_0_to_Infm" would represent layer-averaging over the entire depth.' '' '' '' '';...
            '' '3. If the user specifies a depth range, the column title will indicate it (e.g. "dpthrng_1.2_to_5m" would show resultant layer-averaged velocities over depths from 1.2 to 5 meters).' '' '' '' '';...
            '' '4. NULL or missing data are represented as "-9999".' '' '' '' '';...
            'Smoothed_Planview:' '' '' '' '' '';...
            '' '1. Units are indicated in the column titles.' '' '' '' '';...
            '' '2. Data are the actual vectors shown in the Planview plot, and reflect any user specified smoothing and/or spacings.' '' '' '' '';...
            '' '3. Values are for layer-avg quanties. Thus "dpthrng_0_to_Infm" would represent layer-averaging over the entire depth.' '' '' '' '';...
            '' '4. If the user specifies a depth range, the column title will indicate it (e.g. "dpthrng_1.2_to_5m" would show resultant layer-averaged velocities over depths from 1.2 to 5 meters).' '' '' '' '';...
            '' '5. NULL or missing data are represented as "-9999".' '' '' '' '';...
            '' '' '' '' '' '';...
            'Further Notes:' '' '' '' '' '';...
            '' '1. Timestamp values represent the average time over which the data are sampled. In the case of the Planview ' '' '' '' '';...
            '' '   and MeanCrossSection worksheets, timestamps are the average based on the nearest ensembles (from the ADCP)' '' '' '' '';...
            '' '   mapped to each grid node. For smoothed outputs, the timestamps are the average time over the smoothing window.' '' '' '' '';...
            '' '   Thus if the smoothing window is 2, the time is the average of the 2 grid nodes on either side (5 nodes) of the' '' '' '' '';...
            '' '   center of the smoothing window.' '' '' '' '';...
            '' '' '' '' '' '';...
            '' '' '' '' '' '';...
            'Form last revised:' '' guiparams.vmt_version{2}(2:end) '' '' '';...
            };
        xlswrite(outfile,sout,'VMTSummary','A1');
        
        % Save DAV data to an Excel File
        vmin = num2str(guiparams.depth_range_min);
        vmax = num2str(guiparams.depth_range_max);
        pvheaders = {...
            'Timestamp' 'FileName' 'UTM_East' 'UTM_North' 'Dist_m' 'Bed_Elev_m'...
            ['EastDAV_cm/s, dpth rng ' vmin ' to ' vmax ' m']...
            ['NorthDAV_cm/s, dpth rng ' vmin ' to ' vmax ' m']...
            'Vel_mag_cm/s' 'Vel_dir_deg'};
        
        % Initialize Variables
        pvdata = []; Dist = []; ID = {};
        X = []; Y = []; E = []; T = [];
        Ve = []; Vn =[]; Vm = []; Vd = [];
        
        % Concatenate data from all MAT files into arrays
        for i = 1:length(guiparams.mat_file)
            % Load current MAT-file
            load(fullfile(guiparams.mat_path, guiparams.mat_file{i}))
            
            % Location, Time and Bathy
            ID = vertcat(ID,repmat(guiparams.mat_file(i),length(V.mcsX(1,:)),1));
            X = [X V.mcsX(1,:)];
            Y = [Y V.mcsY(1,:)];
            Dist = [Dist sort(V.mcsDist(1,:),'descend')];
            E = [E V.mcsBedElev];
            T = [T V.mcsTime(1,:)];
            
            % Build layer-averaged velocities
            indx = find(V.mcsDepth(:,1) < str2num(vmin) | V.mcsDepth(:,1) > str2num(vmax));
            V.mcsX(indx,:) = nan;
            V.mcsY(indx,:) = nan;
            V.mcsEast(indx,:) = nan;
            V.mcsNorth(indx,:) = nan;
            Ve = [Ve VMT_LayerAveMean(V.mcsDepth,V.mcsEast)];
            Vn = [Vn VMT_LayerAveMean(V.mcsDepth,V.mcsNorth)];
            Vm = [Vm sqrt(VMT_LayerAveMean(V.mcsDepth,V.mcsEast).^2 + VMT_LayerAveMean(V.mcsDepth,V.mcsNorth).^2)];
            Vd = [Vd ari2geodeg(atan2(VMT_LayerAveMean(V.mcsDepth,V.mcsNorth),VMT_LayerAveMean(V.mcsDepth,V.mcsEast))*180/pi)];
            
            waitbar(i/(length(guiparams.mat_file)+1),hwait)
        end
        
        % Put output into 1 matrix
        pvdata = [...
            X; Y; Dist; E;... % Bathy and locations
            Ve; Vn; Vm; Vd... % Velocity
            ];
        pvdata(isnan(pvdata)) = -9999;
        
        % Create table and write to Excel
        pvout = num2cell(pvdata');
        pvout = horzcat(ID,pvout);
        timestamp = cellstr(nandatestr(T));
        pvout = vertcat(pvheaders,horzcat(timestamp,pvout));
        xlswrite(outfile,pvout,'Planview');
        
        % Save the actual Planview plot data, which includes the smoothed
        % results
        PVheaders = {...
            'Timestamp' 'FileName'...
            'UTM_East_WGS84' 'UTM_North_WGS84' 'Dist_m'...
            ['EastDAV_cms_dpthrng_' vmin '_to_' vmax 'm']...
            ['NorthDAV_cms_dpthrng_' vmin '_to_' vmax 'm']...
            'Vel_mag_cms' 'Vel_dir_deg'};
        PVtable = [...
            PVdata.outmat(1,:);...
            PVdata.outmat(2,:);...
            PVdata.outmat(7,:);...;...
            PVdata.outmat(4,:).*100;...
            PVdata.outmat(5,:).*100;...
            sqrt(PVdata.outmat(4,:).^2 + PVdata.outmat(5,:).^2).*100;...
            ari2geodeg(atan2(PVdata.outmat(5,:), PVdata.outmat(4,:))*180/pi)];
        %PVtable = (sortrows(PVtable',3))';
        PVtable(isnan(PVtable)) = -9999;
        PVout = horzcat(...
            cellstr(nandatestr(PVdata.outmat(6,:)')),...
            PVdata.outfile,...
            num2cell(PVtable'));
        PVout = vertcat(PVheaders,PVout);
        xlswrite(outfile,PVout,'Smoothed_Planview');
        
        % Close out waitbar
        waitbar(1,hwait)
        delete(hwait)
        
        
    case 'Single'
        %% Single Cross Section Loaded
        log_text = vertcat(log_text,{'Writing data to Excel file...'});
        ID = PVdata.outfile;         % File name for for each data point in the
        % planview plot
        switch V.startBank  %Get the streamwise direction from true north to report in the excel file (depends on start bank)
            case 'right_bank'
                strmwise = V.phi - 180;
                if strmwise < 0
                    strmwise = 360 + strmwise;
                end
                vsgn = 1;
            otherwise % 'left_bank' or 'auto'
                strmwise = V.phi;
                vsgn = -1;
        end
        
        % Compute the ZSD positive secondary flow direction
        poszsdvs = V.phisp - 90;
        if poszsdvs < 0
            poszsdvs = 360 + poszsdvs;
        end
            
            % Save MCS Summary to an Excel File
            hwait = waitbar(0,'Exporting Excel File...');
            xlswrite(outfile,{'Path:'}, 'VMTSummary','H3');
            xlswrite(outfile,{'Files:'},'VMTSummary','H4');
            waitbar(1/5,hwait)
            
            sout = dataFiles;
            xlswrite(outfile,sout,'VMTSummary','I4');
            waitbar(2/7,hwait)
            for zi=1:z;
                mintime(zi) = nanmin(A(zi).Comp.enstime);
                maxtime(zi) = nanmin(A(zi).Comp.enstime);
            end
            sout = {...
                'VMT: SUMMARY OF OUTPUT' '' '' '' '' '';...
                'VMT version: ' guiparams.vmt_version{1} guiparams.vmt_version{2} '' '' '';...
                'Date Processed: ' datestr(now) '' '' '' '';...
                '' '' '' '' '' '';...
                'MEAN CROSS SECTION (MCS) PROPERTIES' '' '' '' '' '';...
                'Horz. Grid Node Spacing (m):' '' '' '' '' A(1).hgns;...
                'Vert. Grid Node Spacing (m):' '' '' '' '' A(1).vgns;...
                'Water Surface Elevation (m):'  '' '' '' '' A(1).wse;...
                'Time of first velocity sample:'  '' '' '' '' datestr(nanmin(mintime));...
                'Time of last velocity sample:'  '' '' '' '' datestr(nanmax(maxtime));...
                'Time of first velocity grid node:'  '' '' '' '' datestr(nanmin(V.mcsTime(:)));...
                'Time of last velocity grid node:'  '' '' '' '' datestr(nanmax(V.mcsTime(:)));...
                'Slope'	'' '' '' '' V.m;...
                'Intercept'	'' '' '' '' V.b;...
                'Theta (mean XS orientation, in deg. from true north)'	'' '' '' '' V.theta
                'MCS Endpoints:' '' '' '' 'UTM Easting (WGS84), in meters'	'UTM Northing (WGS84), in meters';...
                'Left Bank'	'' '' ''	V.xLeftBank V.yLeftBank;...
                'Right Bank'	'' '' ''	V.xRightBank V.yRightBank;...
                'Total Length in meters' '' '' '' '' V.dl;...
                '' '' '' '' '' '';...
                'SMOOTHED (SPATIALLY-AVERAGED) DATA PROPERTIES' '' '' '' '' '';...
                'Smoothed Planview:' '' '' '' '' '';...
                'Vector Spacing, in ground distance (m)' '' '' '' ''  num2str(guiparams.vector_spacing_plan_view*guiparams.horizontal_grid_node_spacing);...
                'Vector Smoothing, in ground distance (m)' '' '' '' '' num2str(2*guiparams.smoothing_window_size*guiparams.horizontal_grid_node_spacing);...
                'Smoothed Mean Cross Section:' '' '' '' '' '';...
                'Horizontal Vector Spacing, in ground distance (m)' '' '' '' '' num2str(guiparams.horizontal_vector_spacing*guiparams.horizontal_grid_node_spacing);...
                'Horizontal Vector Smoothing, in ground distance (m)' '' '' '' '' num2str(2*guiparams.horizontal_smoothing_window*guiparams.horizontal_grid_node_spacing);...
                'Vertical Vector Spacing, in ground distance (m)' '' '' '' '' num2str(guiparams.vertical_vector_spacing*guiparams.vertical_grid_node_spacing);...
                'Vertical Vector Smoothing, in ground distance (m)' '' '' '' '' num2str(2*guiparams.vertical_smoothing_window*guiparams.vertical_grid_node_spacing);...
                '' '' '' '' '' '';...
                'FLOW ORIENTATION' '' '' '' '' '';...
                'Mean Flow Direction (deg. from true north)' '' '' '' '' num2str(V.mfd);...
                'Positive Streamwise Flow Direction (Normal to mean XS; deg. from true north)' '' '' '' '' num2str(V.phi);...
                'Positive Transverse Flow Direction (Parallel to mean XS; deg. from true north)' '' '' '' '' num2str(V.theta);...
                'Positive Primary Flow Direction (ZSD; deg. from true north)' '' '' '' '' num2str(V.phisp);...
                'Positive Secondary Flow Direction (ZSD; deg. from true north)' '' '' '' '' num2str(poszsdvs);...
                'Positive Primary Flow Direction (ROZ, downstream component; deg. from true north)' '' '' '' '' num2str(V.phi);...
                'Positive Secondary Flow Direction (ROZ, cross-stream component; deg. from true north)' '' '' '' '' num2str(V.theta);...
                'Positive Vertical Velocity is up or towards the water surface' '' '' '' '' '';...
                'NOTE: Primary and secondary flow computations are defined for rivers. These computations are unreliable when applied to lakes and similar water bodies.' '' '' '' '' '';...
                '' '' '' '' '' '';...
                '' '' '' '' '' '';...
                'DATA STRUCTURE' '' '' '' '' '';...
                '' '1. These data are the computed output from The Velocity Mapping Toolbox (VMT).' '' '' '' '';...
                '' '2. VMT maps the loaded ADCP data to a mean cross-section (MCS), typically a line of best fit to the ADCP positions.' '' '' '' '';...
                '' '3. The ADCP data are then interpolated to a user specified grid (see Cells F6:F7).' '' '' '' '';...
                '' '4. VMT then averages the mapped and interpolated data to the MCS grid.' '' '' '' '';...
                '' '5. For more information, see the VMT homepage: ' '' '' '' '';...
                '' '=HYPERLINK("http://hydroacoustics.usgs.gov/movingboat/VMT/VMT.shtml")' '' '' '' '';...
                'Planview:' '' '' '' '' '';...
                '' '1. Units are indicated in the column titles.' '' '' '' '';...
                '' '2. Values are for layer-avg quanties. Thus "dpthrng_0_to_Infm" would represent layer-averaging over the entire depth.' '' '' '' '';...
                '' '3. If the user specifies a depth range, the column title will indicate it (e.g. "dpthrng_1.2_to_5m" would show resultant layer-averaged velocities over depths from 1.2 to 5 meters).' '' '' '' '';...
                '' '4. NULL or missing data are represented as "-9999".' '' '' '' '';...
                'MeanCrossSection:' '' '' '' '' '';...
                '' '1. Data are in vectorized i,j structure, where i is the index into the horizontal, j is index to vertical. Thus, the first j rows correspond to vertical i.' '' '' '' '';...
                '' '2. Bed elevation is computed as the entered water surface elevation minus depth at each vertical location (if WSE=0, the elevations will be negative).' '' '' '' '';...
                '' '3. NULL or missing data are represented as "-9999".' '' '' '' '';...
                'Smoothed_Planview:' '' '' '' '' '';...
                '' '1. Units are indicated in the column titles.' '' '' '' '';...
                '' '2. Data are the actual vectors shown in the Planview plot, and reflect any user specified smoothing and/or spacings.' '' '' '' '';...
                '' '3. Values are for layer-avg quanties. Thus "dpthrng_0_to_Infm" would represent layer-averaging over the entire depth.' '' '' '' '';...
                '' '4. If the user specifies a depth range, the column title will indicate it (e.g. "dpthrng_1.2_to_5m" would show resultant layer-averaged velocities over depths from 1.2 to 5 meters).' '' '' '' '';...
                '' '5. NULL or missing data are represented as "-9999".' '' '' '' '';...
                'Smoothed_MeanCrossSection:' '' '' '' '' '';...
                '' '1. Units are indicated in the column titles.' '' '' '' '';...
                '' '2. Data are the actual vectors shown in the Mean Cross Section plot, and reflect any user specified smoothing and/or spacings.' '' '' '' '';...
                '' '3. NULL or missing data are represented as "-9999".' '' '' '' '';...
                '' '' '' '' '' '';...
                'Further Notes:' '' '' '' '' '';...
                '' '1. Timestamp values represent the average time over which the data are sampled. In the case of the Planview ' '' '' '' '';...
                '' '   and MeanCrossSection worksheets, timestamps are the average based on the nearest ensembles (from the ADCP)' '' '' '' '';...
                '' '   mapped to each grid node. For smoothed outputs, the timestamps are the average time over the smoothing window.' '' '' '' '';...
                '' '   Thus if the smoothing window is 2, the time is the average of the 2 grid nodes on either side (5 nodes) of the' '' '' '' '';...
                '' '   center of the smoothing window.' '' '' '' '';...
                '' '2. Secondary flow definitions: ZSD = Zero Secondary Discharge definition; ROZ = Rozovsky definition.' '' '' '' '';...
                '' '3. Other definitions: DAV = depth=-averaged velocity; WGS84 = World Geodetic System of 1984; dpthrng = depth range; Inf = infinity; m = meters; cm/s or cms = centimeters per second; deg. = degrees.' '' '' '' '';...
                '' '' '' '' '' '';...
                '' '' '' '' '' '';...
                'Form last revised:' '' guiparams.vmt_version{2}(2:end) '' '' '';...
                };
            xlswrite(outfile,sout,'VMTSummary','A1');
            waitbar(3/7,hwait)
            
            % Save DAV data to an Excel File
            vmin = num2str(guiparams.depth_range_min);
            vmax = num2str(guiparams.depth_range_max);
            pvheaders = {...
                'Timestamp'...
                ...'FileName'...
                'UTM Easting (WGS84), in meters' 'UTM Northing (WGS84), in meters' 'Distance, in meters' 'Bed Elevation, in meters'...
                ['EastDAV_cms_dpthrng_' vmin '_to_' vmax 'm']...
                ['NorthDAV_cms_dpthrng_' vmin '_to_' vmax 'm']...
                'Velocity magnitude, in cm/s' 'Velocity direction, in deg. from true north'};
            
            % Create block style matrix of all processed data
            % This does not include the smoothed data results from the plots.
            % This is for EACH grid node specified by hgns/vgns, with the
            % layer-averaging applied
            pvdata = [];
            
            % Stationing from LEFT bank
            Dist = V.mcsDist;
            
            % Build bathy data matrix
            pvdata = [V.mcsX(1,:); V.mcsY(1,:); Dist(1,:); V.mcsBedElev];
            
            % Build layer-averaged velocities
            indx = find(V.mcsDepth(:,1) < str2num(vmin) | V.mcsDepth(:,1) > str2num(vmax));
            V.mcsX(indx,:) = nan;
            V.mcsY(indx,:) = nan;
            V.mcsEast(indx,:) = nan;
            V.mcsNorth(indx,:) = nan;
            pvdata = [...
                pvdata;...
                VMT_LayerAveMean(V.mcsDepth,V.mcsEast);...
                VMT_LayerAveMean(V.mcsDepth,V.mcsNorth);...
                sqrt(VMT_LayerAveMean(V.mcsDepth,V.mcsEast).^2 + VMT_LayerAveMean(V.mcsDepth,V.mcsNorth).^2);...
                ari2geodeg(atan2(VMT_LayerAveMean(V.mcsDepth,V.mcsNorth), VMT_LayerAveMean(V.mcsDepth,V.mcsEast))*180/pi)];
            pvdata(isnan(pvdata)) = -9999;
            pvout = num2cell(pvdata');
            %pvout = horzcat(repmat(ID(1),length(pvout(:,1)),1),pvout);
            timestr = nandatestr(V.mcsTime(1,:));
            timestamp = cellstr(timestr);
            pvout = horzcat(timestamp,pvout);
            pvout = vertcat(pvheaders,pvout);
            xlswrite(outfile,pvout,'Planview');
            waitbar(4/7,hwait)
            
            % Save MCS data to an Excel File
            % This does not include the smoothed data results from the plots.
            % This is for EACH grid node specified by hgns/vgns
            MCSheaders = {...
                'Timestamp'...
                'UTM Easting (WGS84), in meters' ...
                'UTM Northing (WGS84), in meters'...
                'Depth from surface, in meters'...
                'Distance from Left Bank, in meters'...
                'Bed Elevation, in meters'...
                ...'Bed Elevation, in meters'...
                'East Velocity, in cm/s'...
                'North Velocity, in cm/s'...
                'Vertical Velocity, in cm/s'...
                'Velocity Magnitude, in cm/s'...
                'Velocity Direction, in degrees from true north'...
                'Streamwise Velocity, in cm/s'...
                'Transverse Velocity, in cm/s'...
                'Primary Velocity (ZSD), in cm/s'...
                'Secondary Velocity (ZSD), in cm/s'...
                'Primary Velocity (ROZ, downstream comp.), in cm/s'...
                'Secondary Velocity (ROZ, cross-stream comp.), in cm/s'};
            
            vectorized_bed = meshgrid(V.mcsBedElev,V.mcsDepth(:,1));
            MCSdata = [...
                V.mcsX(:)...
                V.mcsY(:)...
                V.mcsDepth(:)...
                V.mcsDist(:)...
                vectorized_bed(:)...
                ...(str2num(wse) - V.mcsDepth(:))...
                ...repmat((wse - V.mcsBed(:)),size(V.mcsX,1),1)...
                V.mcsEast(:)...
                V.mcsNorth(:)...
                V.mcsVert(:)...
                V.mcsMag(:)...
                V.mcsDir(:)...
                V.u(:)...
                V.v(:)...
                V.vp(:)...
                V.vs(:)...
                V.Roz.upx(:)...
                V.Roz.usy(:)];
            MCSdata(isnan(MCSdata)) = -9999;
            timestamp = cellstr(nandatestr(V.mcsTime(:)));
            MCSout = vertcat(MCSheaders,horzcat(timestamp,num2cell(MCSdata)));
            xlswrite(outfile,MCSout,'MeanCrossSection');
            waitbar(5/7,hwait)
            
            % Save the actual Planview plot data, which includes the smoothed
            % results
            % Compute distance from the LEFT bank using the MCS endpoints
            PVDist = hypot(V.xLeftBank-PVdata.outmat(1,:),V.yLeftBank-PVdata.outmat(2,:));
            PVheaders = {...
                'Timestamp'...
                'UTM Easting (WGS84), in meters'...
                'UTM Northing (WGS84), in meters'...
                'Distance, in meters'...
                ['EastDAV_cms_dpthrng_' vmin '_to_' vmax 'm']...
                ['NorthDAV_cms_dpthrng_' vmin '_to_' vmax 'm']...
                'Velocity magnitude, in cm/s'...
                'Velocity direction, in deg. from true north'};
            PVtable = [...
                PVdata.outmat(1,:);...
                PVdata.outmat(2,:);...
                PVDist;...
                PVdata.outmat(4,:).*100;...
                PVdata.outmat(5,:).*100;...
                sqrt(PVdata.outmat(4,:).^2 + PVdata.outmat(5,:).^2).*100;...
                ari2geodeg(atan2(PVdata.outmat(5,:), PVdata.outmat(4,:))*180/pi)];
            PVtable = (sortrows(PVtable',3))';
            PVtable(isnan(PVtable)) = -9999;
            PVout = horzcat(cellstr(nandatestr(PVdata.outmat(6,:)')), num2cell(PVtable'));
            PVout = vertcat(PVheaders,PVout);
            xlswrite(outfile,PVout,'Smoothed_Planview');
            waitbar(6/7,hwait)
            
            % Save the actual MCS plot data, which includes the smoothed
            % results
            % Distance is from the LEFT bank
            % Doesn't include the reference vector
            compstr = [guiparams.contour '_' guiparams.secondary_flow_vector_variable];
            dist    = guiparams.mcsQuivers(1:end-1,1);
            depth   = guiparams.mcsQuivers(1:end-1,2);
            vcomp   = vsgn*guiparams.mcsQuivers(1:end-1,3)/guiparams.vector_scale_cross_section; %Must remove scale factor and correct sign for XS flipping
            switch guiprefs.plotref
                case 'dfs'
                    wcomp   = guiparams.mcsQuivers(1:end-1,4)/(-guiparams.vector_scale_cross_section/guiparams.vertical_exaggeration); %Must remove scale factor and exaggeration and reverse sign (all done in plotting)
                case 'hab'
                    wcomp   = guiparams.mcsQuivers(1:end-1,4)/(guiparams.vector_scale_cross_section/guiparams.vertical_exaggeration); %Must remove scale factor and exaggeration
            end
            
            % Compute an UTM coordinate for the vector
            pUTMx = interp1(V.mcsDist(1,:),V.mcsX(1,:),dist);
            pUTMy = interp1(V.mcsDist(1,:),V.mcsY(1,:),dist);
            
            % Compute a Time for each vector
            pTime = interp1(V.mcsDist(1,:),V.mcsTime(1,:),dist);
            
            % Compute the streamwise component at each vector in the MCS plot
            switch guiparams.contour
                case 'streamwise'   %Plots the streamwise velocity
                    wtp=['V.uSmooth'];
                case 'transverse'  %Plots the transverse velocity
                    wtp=['V.vSmooth'];
                case 'vertical'  %Plots the vertical velocity
                    wtp=['V.wSmooth'];
                case 'mag'  %Plots the velocity magnitude
                    wtp=['V.mcsMagSmooth'];
                case 'east'  %Plots the east velocity
                    wtp=['V.mcsEastSmooth'];
                case 'error'  %Plots the error velocity
                    wtp=['V.mcsErrorSmooth'];
                case 'north'  %Plots the north velocity
                    wtp=['V.mcsNorthSmooth'];
                case 'primary_zsd'   %Plots the primary velocity with zero secondary discharge definition
                    wtp=['V.vpSmooth'];
                case 'secondary_zsd'  %Plots the secondary velocity with zero secondary discharge definition
                    wtp=['V.vsSmooth'];
                case 'primary_roz'   %Plots the primary velocity with Rozovskii definition
                    wtp=['V.Roz.upSmooth'];
                case 'secondary_roz'  %Plots the secondary velocity with Rozovskii definition
                    wtp=['V.Roz.usSmooth'];
                case 'primary_roz_x'   %Plots the primary velocity with Rozovskii definition (downstream component)
                    wtp=['V.Roz.upxSmooth'];
                case 'primary_roz_y'   %Plots the primary velocity with Rozovskii definition (cross-stream component)
                    wtp=['V.Roz.upySmooth'];
                case 'secondary_roz_x'  %Plots the secondary velocity with Rozovskii definition (downstream component)
                    wtp=['V.Roz.usxSmooth'];
                case 'secondary_roz_y'  %Plots the secondary velocity with Rozovskii definition (cross-stream component)
                    wtp=['V.Roz.usySmooth'];
                case 'backscatter'  %Plots the backscatter
                    wtp=['V.mcsBackSmooth'];
                case 'flowangle'  %Plots the flow direction (N = 0.0 deg)
                    wtp=['V.mcsDirSmooth'];
                case 'vorticity_vw'
                    wtp=['V.vorticity_vw'];
                case 'vorticity_zsd'
                    wtp=['V.vorticity_zsd'];
                case 'vorticity_roz'
                    wtp=['V.vorticity_roz'];
            end
            Ucomp = eval(wtp);
            ucomp = interp2(V.mcsDist,V.mcsDepth,Ucomp,dist,depth);
            
            % Save MCS data to an Excel File
            % This includes the smoothed data results from the plots.
            % This is for EACH VECTOR on the MCS plot
            u_str = regexprep(lower(guiparams.contour),'(\<[a-z])','${upper($1)}');
            v_str = regexprep(lower(guiparams.secondary_flow_vector_variable),'(\<[a-z])','${upper($1)}');
            mcsheaders = {...
                'Timestamp'...
                'UTM Easting (WGS84), in meters'...
                'UTM Northing (WGS84), in meters'...
                'Depth from surface, in meters'...
                'Distance from left bank, in meters'...
                ...'Bed Elevation, in meters'...
                [u_str ' Velocity, in cm/s']...
                [v_str ' Velocity, in cm/s']...
                'Vertical Velocity, in cm/s'...
                };
            mcsdata = [...
                pUTMx(:)...
                pUTMy(:)...
                depth(:)...
                dist(:)...
                ucomp(:)...
                vcomp(:)...
                wcomp(:)];
            % Keep only data where there is a full 3D vector (u,v,w)
            ridx = ~isnan(ucomp);
            mcsdata = mcsdata(ridx,:);
            mcsdata(isnan(mcsdata)) = -9999;
            mcsout = vertcat(mcsheaders,horzcat(cellstr(nandatestr(pTime(ridx))), num2cell(mcsdata)));
            xlswrite(outfile,mcsout,'Smoothed_MeanCrossSection');
            waitbar(7/7,hwait)
            
%         else
%             % Return default excel_path and excel_file
%             excel_path = guiprefs.excel_path;
%             excel_file = guiprefs.excel_file;
%             outfile = fullfile(excel_path,excel_file);
%             log_text = {'User aborted Excel export...'};
%         end
        
    otherwise
end